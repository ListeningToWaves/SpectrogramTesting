<link rel="import" href="./bower_components/polymer/polymer.html">
<link href='https://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>

<polymer-element name="g-oscillator" attributes="log speed resolutionMax resolutionMin square scale fadeInTime fadeOutTime sound timbre outputVolume analyser currentScale currentMode headphoneMode softSnap vibrato">
  <template>
  <style>
  :host {
     --vibrato-top: 50%;
     --vibrato-right: 30%;
  }
  .vibrato{
    position: absolute;
    top: var(--vibrato-top);
    right: var(--vibrato-right);
    z-index: 2;

  }
  .vibrato-title{
    position: absolute;
    right: 30%;
    top: 35%;
    z-index: 2;

    color: white;
  margin-left: 10px;

  }

  #softSnap {

    -webkit-transform:rotate(-90deg);
       -moz-transform:rotate(-90deg);
         -o-transform:rotate(-90deg);
            transform:rotate(-90deg);
  }
    canvas {
      position: absolute;
      width: 100%;
      height: 100%;
    }
  </style>
  <template if="{{multi}}">
  <div class="vibrato-title">
  <label for="ticks">Vibrato&nbsp;</label>
      {{vibrato}}
  </div>
  <div class="config contain vibrato">

    <input type="range" id="softSnap" value="{{vibrato}}" min="-4" max="4" disabled  />


  </div>
</template>
  <canvas id="freq"
      on-mousedown={{onMouseDown}}
      on-mouseup={{onMouseUp}}
      on-mousemove={{onMouseMove}}
      on-mouseout={{onMouseOut}}
      on-touchstart={{onTouchStart}}
      on-touchend={{onTouchEnd}}
      on-touchmove={{onTouchMove}}></canvas>
  </template>
  <script>
    // Assumes context is an AudioContext defined outside of this class.
    Polymer('g-oscillator', {
      gainAmount: 0.2,
      history: [],
      log: false,
      speed: 2,
      fadeInTime: 10,
      fadeOutTime: 10,
      resolutionMax: 20000,
      resolutionMin: 10,
      square: false,
      scale: false,
      // Scales are Major from 0-11, Minor from 12-23.
      notes: ['A', 'A#/Bb', 'B', 'C', 'C#/Db', 'D', 'D#/Eb', 'E', 'F', 'F#/Gb', 'G', 'G#/Ab'],
      scaleNames: [],

      textLabel: 'C 0',
      // scaleChoice: localStorage.getItem('scaleChoice') || 0,
      // modeChoice: localStorage.getItem('modeChoice') || 0,
      varChanged: true,
      sound: 0,
      timbre: 0,
      outputVolume: 50,
      currentScale: 3,
      currentMode: 0,
      headphoneMode: false,
      lastX_: new Array(),
      lastY_: new Array(),
      lastFreq_: new Array(),
      multigain: new Array(),
      multiosc: new Array(),
      multi: false,
      touches: 0,
      softSnap: false,
      vibrato: 0,

      attachedCallback: function() {
        this.loop();
      },

      // Controls the loop of the drawing of the line when dragged
      loop: function() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;

        this.addHistory(this.lastY);
        var canvas = this.$.freq;
        var ctx = canvas.getContext('2d');
        canvas.width = this.width;
        canvas.height = this.height;

        var size = 6;
        var nyquist = context.sampleRate / 2;

        // for (var i = 0; i < this.history.length; i++) {
        //
        //
        //   var y = this.history[i];
        //
        //   if (y === null) {
        //     continue;
        //   }
        //   var x = this.width - (this.history.length - i - 1) * this.speed;
        //   // TODO(smus): Elimiate fudge factor.
        //
        //
        //   if (this.scale) {
        //     var color = this.volume * 245;
        //     var colorVal = 'hsl(H, 100%, 70%)'.replace(/H/g, 255 - color);
        //     ctx.fillStyle = colorVal;
        // ctx.fillRect(x - size / 2, y - size / 2+1, size, size/2);
        //   }
        // }

        if (this.osc_) {
          // Label the point.
          var label = this.formatFrequency_(this.lastFreq);
          if (this.scale) {
            label = label + " " + this.textLabel;
          }
          ctx.font = '20px Inconsolata';
          ctx.fillStyle = 'white'
          ctx.fillText(label, this.lastX, this.lastY);
        }
        requestAnimationFrame(this.loop.bind(this));
      },

      generateScale: function(startFreq, type) {
        this.scaleNames = [];
        var scale = [];
        var scalePattern = [];
        var tuning = 440;
        var tuning_ = tuning / 32;
        switch (type) {
          case 0:
            // Major
            scalePattern = [0, 2, 4, 5, 7, 9, 11];
            break;
          case 1:
            // Minor
            scalePattern = [0, 2, 3, 5, 7, 8, 10];
            break;
          case 2:
            // Major Pentatonic
            scalePattern = [0, 2, 4, 7, 9];
            break;
          case 3:
            // Chromatic
            scalePattern = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
            break;
          case 4:
            // Major Blues
            scalePattern = [0, 3, 5, 6, 7, 10];
            break;
          case 5:
            // Flemenco/Harmonic Major
            scalePattern = [0, 1, 4, 5, 7, 8, 10];
            break;
          case 6:
            // Hungarian Minor
            scalePattern = [0, 2, 3, 6, 7, 8, 11];
            break;
          case 7:
            // Heptatonic 1
            scalePattern = [0, 1, 4, 5, 7, 8, 11];
            break;
          case 8:
            // Heptatonic 2
            scalePattern = [0, 2, 4, 5, 7, 8, 10];
            break;
          case 9:
            // Heptatonic 3
            scalePattern = [0, 2, 3, 5, 7, 9, 10];
            break;
          case 10:
            // Heptatonic 4
            scalePattern = [0, 2, 3, 6, 7, 9, 10];
            break;
          case 11:
            // Heptatonic 5
            scalePattern = [0, 1, 3, 5, 7, 8, 10];
            break;
          case 12:
            // Heptatonic 6
            scalePattern = [0, 2, 4, 5, 7, 9, 10];
            break;
          case 13:
            // Hexatonic 1
            scalePattern = [0, 2, 3, 5, 7, 8];
            break;
          case 14:
            // Hexatonic 2
            scalePattern = [0, 1, 3, 5, 7, 8];
            break;
          case 15:
            // Hexatonic 3
            scalePattern = [0, 2, 3, 6, 7, 8];
            break;
          case 16:
            // Hexatonic 4
            scalePattern = [0, 2, 3, 5, 7, 9];
            break;
          case 17:
            // Hexatonic 5
            scalePattern = [0, 1, 4, 5, 7, 8];
            break;
          case 18:
            // Hexatonic 6
            scalePattern = [0, 2, 4, 6, 7, 10];
            break;
          case 19:
            // Pentatonic 1
            scalePattern = [0, 4, 5, 7, 11];
            break;
          case 20:
            // Pentatonic 2
            scalePattern = [0, 5, 7, 8, 10];
            break;
          case 21:
            // Pentatonic 3
            scalePattern = [0, 1, 5, 7, 10];
            break;
          case 22:
            //Mondongo
            scalePattern = [0, 4, 5, 6, 8, 10];
            break;
          case 23:
            //Flat 2nd Major
            scalePattern = [0, 1, 4, 5, 7];
            break;
          case 24:
            //Natural Minor
            scalePattern = [0, 2, 3, 5, 7];
            break;
          case 25:
            //Sharp 2nd Major
            scalePattern = [0, 3, 4, 5, 7];
            break;
          case 26:
            //Lydian
            scalePattern = [0, 2, 4, 6, 7];
            break;
          case 27:
            //Whole Tone
            scalePattern = [0, 2, 4, 6, 8, 10];
            break;

          default:
            scalePattern = [0, 2, 4, 5, 7, 9, 11];

        }
        for (var i = 0; i < scalePattern.length; i++) {
          var currentF = Number(startFreq) + scalePattern[i];
          scale.push(tuning_ * Math.pow(Math.pow(2, 1 / 12), currentF));
          this.scaleNames.push(this.notes[currentF % 12]);
        }
        // console.log("SCALES");
        // console.log(scale);
        // console.log(this.scaleNames);

        return scale;
      },

      //Adds 'hz' to frequencies when drawn
      formatFrequency_: function(freq) {
        return Math.round(freq) + ' Hz';
      },

      //The next few functions detail the events of mouse/touch down, drag, and up
      //
      onMouseDown: function(event) {

        if (this.osc_) {
          // There can be only one oscillator.
          return;
        }
        this.varChanged = true;
        this.updatePointer(event);

        // Create an oscillator.
        this.osc_ = this.createOscillator_();
        var x = this.lastX;
        var y = event.pageY || event.touches[0].pageY;
        this.lastFreq = this.getLastFrequency(x, y);
        this.osc_.frequency.value = this.lastFreq;
        this.setVolume(this.lastX);

        //Square wave settings, odd harmonics only
        // if (this.square) {
        //   if (this.osc2_) {
        //     return;
        //   }
        //   this.osc2_ = this.createOscillator_("2");
        //   this.osc2_.frequency.value = this.lastFreq * 3;
        //
        //   this.osc3_ = this.createOscillator_("3");
        //   this.osc3_.frequency.value = this.lastFreq * 5;
        //
        //   this.osc4_ = this.createOscillator_("4");
        //   this.osc4_.frequency.value = this.lastFreq * 7;
        //
        //   this.osc5_ = this.createOscillator_("5");
        //   this.osc5_.frequency.value = this.lastFreq * 9;
        //
        //   this.osc6_ = this.createOscillator_("6");
        //   this.osc6_.frequency.value = this.lastFreq * 11;
        // }
      },

      onMouseUp: function() {
        // console.log('mu');
        this.deleteOscillator_();
        this.updatePointer(null);
        this.lastFreq = null;
      },

      onMouseMove: function(event) {
        // console.log('mm');
        if (this.osc_) {
          this.updatePointer(event);
          var x = this.lastX;
          try {
            var y = event.pageY || event.touches[0].pageY;

          } catch (e) {
            console.log(e);
          }
          this.lastFreq = this.getLastFrequency(x, y);

          if (this.scale && this.varChanged) {
            // this.noteChange = true;

            this.deleteOscillator_();
            this.osc_ = this.createOscillator_();
            this.osc_.frequency.value = this.lastFreq;

          } else {
            this.osc_.frequency.value = this.lastFreq;
          }


          this.setVolume(this.lastX);

          // if (this.square) {
          //   if (this.osc2_) {
          //     this.updatePointer(event);
          //     this.osc2_.frequency.value = this.lastFreq * 3;
          //     this.osc3_.frequency.value = this.lastFreq * 5;
          //     this.osc4_.frequency.value = this.lastFreq * 7;
          //     this.osc5_.frequency.value = this.lastFreq * 9;
          //     this.osc6_.frequency.value = this.lastFreq * 11;
          //
          //   }
          //
          // }
        }
      },

      onMouseOut: function(event) {
        // console.log('mo');
        this.deleteOscillator_();
        this.updatePointer(null);
        this.lastFreq = null;
      },

      onTouchStart: function(event) {
        event.preventDefault();
        // console.log('ts');

        //handle multitouch
        // if (event.targetTouches.length == 2) {
        //   console.log("2-tap");
        //   for (var i=0; i < event.targetTouches.length; i++) {
        //     console.log(event.targetTouches.target);
        //   }
        // }
        if (this.osc_) {
          // There can be only one oscillator.

          return;
        }
        this.varChanged = true;
        this.updatePointer(event);



        if (false) {
          for (var i = 0; i < this.touches; i++) {
            this.lastFreq_.push(this.getLastFrequency(this.lastX_[i], this.lastY_[i]));
            this.multiosc.push(this.createOscillator_());
            this.multiosc[i].frequency.value = this.lastFreq_[i];
            console.log(this.multiosc);
            this.setVolume();
          }

        } else {
          // Create an oscillator.
          this.osc_ = this.createOscillator_();
          var x = this.lastX;
          var y = event.pageY || event.touches[0].pageY;
          this.lastFreq = this.getLastFrequency(x, y);
          this.osc_.frequency.value = this.lastFreq;
          this.setVolume(this.lastX);
        }

        //Square wave settings, odd harmonics only
        // if (this.square) {
        //   if (this.osc2_) {
        //     return;
        //   }
        //   this.osc2_ = this.createOscillator_("2");
        //   this.osc2_.frequency.value = this.lastFreq * 3;
        //
        //   this.osc3_ = this.createOscillator_("3");
        //   this.osc3_.frequency.value = this.lastFreq * 5;
        //
        //   this.osc4_ = this.createOscillator_("4");
        //   this.osc4_.frequency.value = this.lastFreq * 7;
        //
        //   this.osc5_ = this.createOscillator_("5");
        //   this.osc5_.frequency.value = this.lastFreq * 9;
        //
        //   this.osc6_ = this.createOscillator_("6");
        //   this.osc6_.frequency.value = this.lastFreq * 11;
        // }

      },
      onTouchMove: function(event) {
        event.preventDefault();
        // console.log('tm');
        if (event.touches.length == 2) {
          this.multi = true;
          // console.log("2-tap");
          if (this.osc_ ) {
            // document.getElementById('softSnap').style.display = 'block';
          var currentPos = this.lastY;
          var vibrato = event.touches[0].pageY;
          // var vibratoSliderYPos = (vibrato/this.height)*100;
          // var vibratoSliderXPos = (event.touches[1].pageX/this.width)*100;
        //vibratoSliderXPos = (vibratoSliderXPos > 5) ? vibratoSliderXPos-5 : vibratoSliderXPos+5;
          // console.log(document.getElementById('softSnap'));

          // console.log(this.customStyle);
          // this.customStyle['--vibrato-top'] = `${vibratoSliderYPos}%`;
          // this.customStyle['--vibrato-left'] = `${vibratoSliderXPos}%`;
          // this.updateStyles();

          // vibrato = (1 - (vibrato / (this.height/2))) * 8 - 4;
          vibrato = (currentPos - vibrato)/2;
          this.vibrato = Math.round(vibrato*100)/100;

//Eliminate Snap
//Fix first frequency
// Change the vibrato to first touch only happens with second finger, change distance


            // console.log(this.softSnap);
            // console.log(newFreq);
            // console.log(newFreq);
            // this.osc_.frequency.setTargetAtTime(newFreq, context.currentTime + 0.01, 0.5);
            // this.setVolume(this.lastX);
            var x = this.lastX;
            var y = event.pageY || event.touches[0].pageY;


            var newFreq = this.getLastFrequency(x,this.lastY-this.vibrato);
            // console.log(newFreq);
            // var newFreq = Math.round(this.lastFreq + this.vibrato);

            //this.lastFreq = this.getLastFrequency(x, y);

            if (this.scale && this.varChanged) {
              // this.deleteOscillator_();
              // this.osc_ = this.createOscillator_();
              if(vibrato != 0){
                this.osc_.frequency.value = newFreq;//, context.currentTime + 0.01, 0.5);

              }
            } else {
              this.osc_.frequency.value = newFreq;//, context.currentTime + 0.01, 0.5);

            }


            this.setVolume(this.lastX);

          } else {
            // for (var i=0; i < event.touches.length; i++) {
            //   if(event.touches[i].target.id === "softSnap"){
            //
            //   }
          }
        } else {
          this.multi = false;
          if (this.osc_) {
            this.updatePointer(event);
            var x = this.lastX;
            var y = event.pageY || event.touches[0].pageY;
            this.lastFreq = this.getLastFrequency(x, y);

            if (this.scale && this.varChanged) {
              this.deleteOscillator_();
              this.osc_ = this.createOscillator_();
              this.osc_.frequency.value = this.lastFreq;

            } else {
              this.osc_.frequency.value = this.lastFreq;//, context.currentTime + 0.01, 0.5);

            }


            this.setVolume(this.lastX);

            // if (this.square) {
            //   if (this.osc2_) {
            //     this.updatePointer(event);
            //     this.osc2_.frequency.value = this.lastFreq * 3;
            //     this.osc3_.frequency.value = this.lastFreq * 5;
            //     this.osc4_.frequency.value = this.lastFreq * 7;
            //     this.osc5_.frequency.value = this.lastFreq * 9;
            //     this.osc6_.frequency.value = this.lastFreq * 11;
            //
            //   }
            //
            // }
          }
        }
      },

      onTouchEnd: function(event) {
        event.preventDefault();
        // console.log('te');
        if (event.touches.length == 0) {
          this.updatePointer(null);
          this.deleteOscillator_();
          this.lastFreq = null;
          this.vibrato = 0;
          return;
        }
        if (this.multi) {
          if (this.touches == 1) {

            this.vibrato = 0;
            this.osc_.frequency.value = this.lastFreq;//, context.currentTime + 0.01, 0.5);
            return;
          } else {

          }
        }
        this.updatePointer(null);
        this.deleteOscillator_();
        this.lastFreq = null;
      },

      // Function that listens for changes in xy pointer position and updates
      // Global variables lastX and lastY
      updatePointer: function(event) {
        event = event || {};
        var type = event.type || '';
        if (type.indexOf('mouse') == 0) {
          this.lastX = event.pageX;
          if (this.varChanged) {
            this.lastY = event.pageY;
          }
        } else if (type.indexOf('touch') == 0) {
          //multitouch
          this.touches = event.touches.length;
          if (this.touches > 1) {
            // this.multi = true;
            for (var i = 0; i < this.touches; i++) {
              this.lastX_.push(event.touches[i].pageX);
              this.lastY_.push(event.touches[i].pageY);
            }
          } else {
            this.multi = false;
            this.lastX = event.touches[0].pageX;
            this.lastY = event.touches[0].pageY;
          }
        } else {
          this.lastX = null;
          this.lastY = null;
        }
      },

      addHistory: function(freq) {
        if (this.history.length > 100) {
          this.history.splice(0, 1);
        }
        this.history.push(freq);
      },

      // Use the X and Y values to calculate frequency for the osc
      getLastFrequency: function(x, y) {


        var percent = 1 - (y / this.height);
        var freq;
        var nyquist = context.sampleRate / 2;
        if (this.log) {
          // percent = this.logScale_(percent * 1000, 1000) / 1000;

          freq = this.newFreqAlgorithm(percent);
        } else {

          freq = Math.floor(percent * (this.resolutionMax - Number(this.resolutionMin)) + Number(this.resolutionMin)) + 1;
        }
        //If snap to scale is on && not multitouch
        if (this.scale && !this.vibrato) {


          var dist = 20000;
          var note = 0;

          // var scaleChoice = localStorage.getItem('scaleChoice') || 3;
          // var modeChoice = localStorage.getItem('modeChoice') || 'major';
          var scaleChoice = (this.currentScale + 3) % 12;
          var modeChoice = this.currentMode;

          // var fullScaleChoice = Number(scaleChoice) + Number(modeChoice)*12;
          // var scale = this.scales[fullScaleChoice];
          var scale = this.generateScale(scaleChoice, modeChoice);
          // var scale = this.generateScale(3, 'Major');
          var name = this.scaleNames[0];
          var harmonic = 0;
          //Sweeps through scale object and plays correct frequency
          for (var j = 1; j < 1500; j = j * 2) {

            for (var k = 0; k < scale.length; k++) {

              var check = j * scale[k];
              var checkDist = Math.abs(freq - check);
              if (checkDist < dist) {
                dist = checkDist;
                note = check;
                name = this.scaleNames[k];
                harmonic = Math.round(Math.log2(j) - 1);
              } else {
                break;
              }
            }
          }
          // if(!this.softSnap && Math.abs(freq - note) > 0.05*note){
          // console.log(this.softSnap);
          // if(this.softSnap && Math.abs(freq - note) < 0.05*note){
          //
          // } else{
          // if(!this.softSnap){
          freq = note;
          // } else{
          // freq = note*(1.0595*this.softSnap/10);

          // }
          // freq = note;
          // }

          // }
          var textLabel = name + '' + harmonic;
          if (this.textLabel === textLabel) {

            this.varChanged = false;
          } else {
            this.varChanged = true;
          }
          this.textLabel = textLabel;
        } else {
          localStorage.removeItem('scaleChoice');
          localStorage.removeItem('modeChoice');
        }
        // if(){
        //   return freq;
        // }
        return freq;
      },

      //Based on x location, sets the volume
      setVolume: function(x) {
        var volume = (x / this.width);
        var logVolume = Math.round(this.logScale_(x, this.width) / 10 * 0.5) / 100 + 0.01;
        this.volume = volume * this.sound;
        this.gainAmount = logVolume * this.sound * (this.outputVolume / 100);
        this.gain_.gain.linearRampToValueAtTime(this.gainAmount,
          context.currentTime + this.fadeInTime / 1000);
        // this.gain_.gain.cancelScheduledValues(startTime);

      },

      createOscillator_: function(i) {
        // Create a gain node.
        var gain = context.createGain();
        // Compressor
        var compressor = context.createDynamicsCompressor();
        // compressor.ratio.value = 20;
        this.compressor = compressor;

        // Create delay offset
        var delay = context.createDelay(1);
        delay.delayTime.value = 0.08;
        // console.log(delay.delayTime.value);


        var harmonicMultiplier = 1;
        gain.gain.value = 0;
        gain.connect(compressor);
        compressor.connect(context.destination);

        if (this.headphoneMode) {
          compressor.connect(this.analyser);
        }
        // delay.connect(this.analyser);

        // gain.connect(context.destination);
        if (false) {
          this.multigain[i] = gain;
        } else {
          this.gain_ = gain;

        }
        // TODO(smus): Clean this up!
        // switch (num) {
        //   case "1":
        //     this.gain1_ = gain;
        //     harmonicMultiplier = 1;
        //   case "2":
        //     this.gain2_ = gain;
        //     harmonicMultiplier = 0.333;
        //   case "3":
        //     this.gain3_ = gain;
        //     harmonicMultiplier = 0.2;
        //   case "4":
        //     this.gain4_ = gain;
        //     harmonicMultiplier = 0.143;
        //   case "5":
        //     this.gain5_ = gain;
        //     harmonicMultiplier = 0.111;
        //   case "6":
        //     this.gain6_ = gain;
        //     harmonicMultiplier = 0.09;
        //
        //     break;
        //   default:
        //
        // }

        // Create an oscillator and connect it through the gain.
        var osc = context.createOscillator();
        switch (this.timbre) {
          case 0:
            osc.type = "sine";
            break;
          case 1:
            osc.type = "sawtooth";
            break;
          case 2:
            osc.type = "square";
            break;
          case 3:
            osc.type = "triangle";
            break;
          default:
            osc.type = "sine";
        }
        // if(this.square){
        //   osc.type = 'square';
        // }

        osc.connect(gain);

        // Start it with a fade-in.
        // gain.gain.linearRampToValueAtTime(this.gainAmount * harmonicMultiplier,
        //   context.currentTime + this.fadeInTime/1000);
        osc.start(0);
        return osc;
      },

      deleteOscillator_: function() {
        if (this.osc_) {

          //   if(this.noteChange){
          //   var endTime = context.currentTime + 10/1000;
          //   this.noteChange = false;
          // } else {

          var endTime = context.currentTime + this.fadeOutTime / 1000;
          this.gain_.gain.cancelAndHoldAtTime(context.currentTime);
          // this.gain_.gain.linearRampToValueAtTime(0, endTime);
          this.gain_.gain.exponentialRampToValueAtTime(0.0001, endTime);
          this.osc_.stop(endTime);
          this.osc_ = null;
          // if (this.square) {
          //   if (this.osc2_) {
          //     this.gain2_.gain.linearRampToValueAtTime(0, endTime);
          //     this.osc2_.stop(endTime);
          //     this.osc2_ = null;
          //
          //     this.gain3_.gain.linearRampToValueAtTime(0, endTime);
          //     this.osc3_.stop(endTime);
          //     this.osc3_ = null;
          //
          //     this.gain4_.gain.linearRampToValueAtTime(0, endTime);
          //     this.osc4_.stop(endTime);
          //     this.osc4_ = null;
          //
          //     this.gain5_.gain.linearRampToValueAtTime(0, endTime);
          //     this.osc5_.stop(endTime);
          //     this.osc5_ = null;
          //
          //     this.gain6_.gain.linearRampToValueAtTime(0, endTime);
          //     this.osc6_.stop(endTime);
          //     this.osc6_ = null;
          //
          //   }
          // }
        }
      },

      newFreqAlgorithm(index) {
        // console.log(index);
        var l = Math.log(this.resolutionMax / this.resolutionMin);
        // console.log(l);
        var freq = this.resolutionMin * Math.pow(Math.E, index * l);
        // console.log(freq);
        return Math.round(freq);

      },

      /**
       * Given an index and the total number of entries, return the
       * log-scaled value.
       */
      logScale_: function(index, total, opt_base) {
        var base = opt_base || 2;
        var logmax = this.logBase(total + 1, base);
        var exp = logmax * index / total;
        return Math.pow(base, exp) - 1;
      },

      logBase: function(val, base) {
        return Math.log(val) / Math.log(base);
      },

      scaleChanged: function() {
        localStorage.removeItem('scaleChoice');
        localStorage.removeItem('modeChoice');
      },
      soundChanged: function() {
        try {
          this.setVolume(this.lastX);

        } catch (e) {
          // console.log(e);
        }
      },
      softSnapChanged: function() {
        // console.log("SOFT");
        if (this.softSnap != 0 && this.osc_) {
          var newFreq = Math.round(this.lastFreq + (this.lastFreq * 1.0595 - this.lastFreq) * this.softSnap / 5);
          // console.log(this.softSnap);
          // console.log(newFreq);
          this.osc_.frequency.setTargetAtTime(newFreq, context.currentTime + 0.01, 0.5);

        } else {
          if (this.osc_) {
            // console.log("HI");
            this.osc_.frequency.setTargetAtTime(this.lastFreq, context.currentTime + 0.01, 0.5);
            this.setVolume(this.lastX);
          }
        }

      },




    });
  </script>
</polymer-element>
